
# 思路 

本题大家多举一个例子，就发现这其实就是斐波那契数列。

题目509. 斐波那契数中的代码初始化部分稍加改动，就可以过了本题。

C++代码如下：
```
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];

    }
};
```

既然这么简单为什么还要讲呢，其实本题稍加改动就是一道面试好题，如果每次可以爬 1 或 2或3或者m 个台阶呢，走到楼顶有几种方法？ 

* 确定dp数组以及下标的含义

dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法

* 确定递推公式 

dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]

那么递推公式为：dp[i] += dp[i - j]

* dp数组如何初始化

既然递归公式是 dp[i] += dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。

下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果 

* 确定遍历顺序

这是背包里求排列问题，即：1 2 步  和 2 1 步都是上三个台阶，但是这两种方法不！

所以需将target放在外循环，将nums放在内循环。

每一步可以走多次，说明这是完全背包，内循环需要从前向后遍历。


C++代码如下：
```
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```

代码中m表示最多可以爬m个台阶，代码中把m改成2就是本题70.爬楼梯的代码了。

# 总结 

如果我来面试的话，我就会想给候选人出一个 本题原题，看其表现，如果顺利写出来，进而在要求每次可以爬[1 - m]个台阶应该怎么写。

顺便再考察一下两个for循环的嵌套顺序，为什么target放外面，nums放里面。这就能反馈出对背包问题本质的掌握程度，是不是刷题背公式，一眼就看出来。

这么一连套下来，如果候选人都能答出来，相信任何一位面试官都是非常满意的。

**本题代码不长，题目也很普通，当稍稍一进阶就可以考察本质问题，而且题目进阶的内容在leetcode上并没有，一定程度上就可以排除掉刷题党了，简直是面试题目的绝佳选择！**

相信通过这道简单的斐波那契数列题目，大家能感受到大厂面试官最喜欢什么样的面试题目了，并不是手撕红黑树！


所以本题是一道非常好的题目。

